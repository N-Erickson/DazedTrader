package algo

import (
	"context"
	"dazedtrader/api"
	"fmt"
	"log"
	"sync"
	"time"
)

// TradingEngine manages algorithmic trading strategies
type TradingEngine struct {
	client         *api.CryptoClient
	strategies     map[string]Strategy
	activeStrategies map[string]*StrategyRunner
	riskManager    *RiskManager
	orderManager   *OrderManager
	priceFeeds     map[string]*PriceFeed

	// Control channels
	stopChan       chan struct{}
	pauseChan      chan bool
	emergencyStop  chan struct{}

	// State
	isRunning      bool
	isPaused       bool
	mu             sync.RWMutex

	// Configuration
	config         *EngineConfig

	// Monitoring
	metrics        *PerformanceMetrics
	logger         *log.Logger
}

// EngineConfig holds engine-wide configuration
type EngineConfig struct {
	MaxConcurrentStrategies int           `json:"max_concurrent_strategies"`
	PriceUpdateInterval     time.Duration `json:"price_update_interval"`
	OrderRetryLimit         int           `json:"order_retry_limit"`
	OrderTimeout            time.Duration `json:"order_timeout"`
	EmergencyStopLoss       float64       `json:"emergency_stop_loss"` // Percentage
	DailyLossLimit          float64       `json:"daily_loss_limit"`    // Dollar amount
	EnableBacktesting       bool          `json:"enable_backtesting"`
	LogLevel                string        `json:"log_level"`
}

// Strategy interface that all trading strategies must implement
type Strategy interface {
	GetName() string
	GetSymbol() string
	Initialize(config StrategyConfig) error
	ProcessTick(tick PriceTick) ([]Signal, error)
	GetState() StrategyState
	Stop() error
	Reset() error
}

// StrategyConfig holds strategy-specific configuration
type StrategyConfig struct {
	Name            string                 `json:"name"`
	Symbol          string                 `json:"symbol"`
	Enabled         bool                   `json:"enabled"`
	Parameters      map[string]interface{} `json:"parameters"`
	RiskLimits      RiskLimits            `json:"risk_limits"`
	BacktestPeriod  time.Duration         `json:"backtest_period"`
}

// RiskLimits defines risk management parameters for a strategy
type RiskLimits struct {
	MaxPositionSize    float64 `json:"max_position_size"`     // USD
	StopLossPercent    float64 `json:"stop_loss_percent"`     // Percentage
	TakeProfitPercent  float64 `json:"take_profit_percent"`   // Percentage
	MaxDailyTrades     int     `json:"max_daily_trades"`
	MaxDailyLoss       float64 `json:"max_daily_loss"`        // USD
	CooldownPeriod     time.Duration `json:"cooldown_period"`
}

// Signal represents a trading signal generated by a strategy
type Signal struct {
	Type      SignalType `json:"type"`
	Symbol    string     `json:"symbol"`
	Price     float64    `json:"price"`
	Quantity  float64    `json:"quantity"`
	Timestamp time.Time  `json:"timestamp"`
	Confidence float64   `json:"confidence"` // 0.0 to 1.0
	Metadata  map[string]interface{} `json:"metadata"`
}

// SignalType represents the type of trading signal
type SignalType string

const (
	SignalBuy  SignalType = "buy"
	SignalSell SignalType = "sell"
	SignalHold SignalType = "hold"
)

// PriceTick represents a price update for a symbol
type PriceTick struct {
	Symbol    string    `json:"symbol"`
	Price     float64   `json:"price"`
	BidPrice  float64   `json:"bid_price"`
	AskPrice  float64   `json:"ask_price"`
	Volume    float64   `json:"volume"`
	Timestamp time.Time `json:"timestamp"`
}

// StrategyState holds the current state of a strategy
type StrategyState struct {
	Name           string                 `json:"name"`
	Symbol         string                 `json:"symbol"`
	IsRunning      bool                   `json:"is_running"`
	Position       Position               `json:"position"`
	PnL            float64                `json:"pnl"`
	TradesCount    int                    `json:"trades_count"`
	LastSignal     *Signal                `json:"last_signal"`
	Metadata       map[string]interface{} `json:"metadata"`
	StartTime      time.Time              `json:"start_time"`
	LastUpdateTime time.Time              `json:"last_update_time"`
}

// Position represents a trading position
type Position struct {
	Symbol       string    `json:"symbol"`
	Quantity     float64   `json:"quantity"`
	AveragePrice float64   `json:"average_price"`
	MarketValue  float64   `json:"market_value"`
	UnrealizedPnL float64  `json:"unrealized_pnl"`
	OpenTime     time.Time `json:"open_time"`
}

// NewTradingEngine creates a new trading engine instance
func NewTradingEngine(client *api.CryptoClient, config *EngineConfig) *TradingEngine {
	engine := &TradingEngine{
		client:           client,
		strategies:       make(map[string]Strategy),
		activeStrategies: make(map[string]*StrategyRunner),
		priceFeeds:       make(map[string]*PriceFeed),
		stopChan:         make(chan struct{}),
		pauseChan:        make(chan bool),
		emergencyStop:    make(chan struct{}),
		config:           config,
		metrics:          NewPerformanceMetrics(),
	}

	// Initialize components
	engine.riskManager = NewRiskManager(config)
	engine.orderManager = NewOrderManager(client, config)

	return engine
}

// RegisterStrategy registers a new trading strategy
func (e *TradingEngine) RegisterStrategy(strategy Strategy) error {
	e.mu.Lock()
	defer e.mu.Unlock()

	name := strategy.GetName()
	if _, exists := e.strategies[name]; exists {
		return fmt.Errorf("strategy %s already registered", name)
	}

	e.strategies[name] = strategy
	return nil
}

// StartStrategy starts a specific strategy
func (e *TradingEngine) StartStrategy(name string, config StrategyConfig) error {
	e.mu.Lock()
	defer e.mu.Unlock()

	strategy, exists := e.strategies[name]
	if !exists {
		return fmt.Errorf("strategy %s not found", name)
	}

	if _, running := e.activeStrategies[name]; running {
		return fmt.Errorf("strategy %s is already running", name)
	}

	// Initialize strategy
	if err := strategy.Initialize(config); err != nil {
		return fmt.Errorf("failed to initialize strategy %s: %v", name, err)
	}

	// Create strategy runner
	runner := NewStrategyRunner(strategy, e.orderManager, e.riskManager, config)
	e.activeStrategies[name] = runner

	// Ensure price feed is available for the symbol
	symbol := config.Symbol
	if _, exists := e.priceFeeds[symbol]; !exists {
		e.priceFeeds[symbol] = NewPriceFeed(symbol, e.client, e.config.PriceUpdateInterval)
		// Start the price feed immediately if engine is running
		if e.isRunning {
			go e.priceFeeds[symbol].Start(context.Background())
		}
	}

	// Connect price feed to strategy runner
	priceFeed := e.priceFeeds[symbol]
	go e.feedPricesToStrategy(priceFeed, runner)

	// Start the strategy runner
	go runner.Run(context.Background())

	return nil
}

// StopStrategy stops a specific strategy
func (e *TradingEngine) StopStrategy(name string) error {
	e.mu.Lock()
	defer e.mu.Unlock()

	runner, exists := e.activeStrategies[name]
	if !exists {
		return fmt.Errorf("strategy %s is not running", name)
	}

	runner.Stop()
	delete(e.activeStrategies, name)

	return nil
}

// Start starts the trading engine
func (e *TradingEngine) Start() error {
	e.mu.Lock()
	defer e.mu.Unlock()

	if e.isRunning {
		return fmt.Errorf("trading engine is already running")
	}

	// Recreate channels if they were closed
	select {
	case <-e.stopChan:
		e.stopChan = make(chan struct{})
	default:
	}

	select {
	case <-e.emergencyStop:
		e.emergencyStop = make(chan struct{})
	default:
	}

	e.isRunning = true
	e.isPaused = false

	// Start price feeds for all active strategies
	for _, feed := range e.priceFeeds {
		go feed.Start(context.Background())
	}

	// Start monitoring goroutines
	go e.monitorEmergencyStop()
	go e.updateMetrics()

	return nil
}

// Stop stops the trading engine and all strategies
func (e *TradingEngine) Stop() error {
	e.mu.Lock()
	defer e.mu.Unlock()

	if !e.isRunning {
		return nil
	}

	// Stop all active strategies (without calling StopStrategy to avoid deadlock)
	for name, runner := range e.activeStrategies {
		runner.Stop()
		delete(e.activeStrategies, name)
	}

	// Stop price feeds
	for _, feed := range e.priceFeeds {
		feed.Stop()
	}

	// Signal shutdown
	select {
	case <-e.stopChan:
		// Already closed
	default:
		close(e.stopChan)
	}
	e.isRunning = false

	return nil
}

// feedPricesToStrategy feeds price updates from a price feed to a strategy runner
func (e *TradingEngine) feedPricesToStrategy(priceFeed *PriceFeed, runner *StrategyRunner) {
	// Create a channel to receive price updates
	priceChan := make(chan PriceTick, 100)

	// Subscribe to the price feed
	priceFeed.Subscribe(priceChan)
	defer priceFeed.Unsubscribe(priceChan)

	for {
		select {
		case <-e.stopChan:
			return
		case <-e.emergencyStop:
			return
		case tick := <-priceChan:
			// Forward the tick to the strategy runner
			runner.ProcessPriceTick(tick)
		}
	}
}

// EmergencyStop immediately stops all trading activity
func (e *TradingEngine) EmergencyStop() error {
	e.mu.Lock()
	defer e.mu.Unlock()

	// Only close channel if still running
	if e.isRunning {
		// Signal emergency stop
		select {
		case <-e.emergencyStop:
			// Already closed
		default:
			close(e.emergencyStop)
		}
	}

	// Cancel all pending orders
	e.orderManager.CancelAllOrders()

	// Stop all strategies immediately
	for name := range e.activeStrategies {
		e.StopStrategy(name)
	}

	e.isRunning = false
	e.isPaused = false

	return nil
}

// Pause pauses all trading strategies
func (e *TradingEngine) Pause() {
	e.mu.Lock()
	defer e.mu.Unlock()

	e.isPaused = true
	e.pauseChan <- true
}

// Resume resumes all trading strategies
func (e *TradingEngine) Resume() {
	e.mu.Lock()
	defer e.mu.Unlock()

	e.isPaused = false
	e.pauseChan <- false
}

// GetActiveStrategies returns information about currently active strategies
func (e *TradingEngine) GetActiveStrategies() map[string]StrategyState {
	e.mu.RLock()
	defer e.mu.RUnlock()

	states := make(map[string]StrategyState)
	for name, runner := range e.activeStrategies {
		states[name] = runner.GetState()
	}

	return states
}

// GetMetrics returns current performance metrics
func (e *TradingEngine) GetMetrics() *PerformanceMetrics {
	e.mu.RLock()
	defer e.mu.RUnlock()

	return e.metrics
}

// IsRunning returns whether the engine is currently running
func (e *TradingEngine) IsRunning() bool {
	e.mu.RLock()
	defer e.mu.RUnlock()

	return e.isRunning
}

// IsPaused returns whether the engine is currently paused
func (e *TradingEngine) IsPaused() bool {
	e.mu.RLock()
	defer e.mu.RUnlock()

	return e.isPaused
}

// monitorEmergencyStop monitors for emergency stop conditions
func (e *TradingEngine) monitorEmergencyStop() {
	ticker := time.NewTicker(time.Second)
	defer ticker.Stop()

	for {
		select {
		case <-e.stopChan:
			return
		case <-e.emergencyStop:
			return
		case <-ticker.C:
			// Check for emergency stop conditions
			if e.shouldEmergencyStop() {
				e.EmergencyStop()
				return
			}
		}
	}
}

// shouldEmergencyStop checks if emergency stop conditions are met
func (e *TradingEngine) shouldEmergencyStop() bool {
	// Check daily loss limit
	if e.config.DailyLossLimit > 0 && e.metrics.DailyPnL < -e.config.DailyLossLimit {
		return true
	}

	// Check emergency stop loss percentage
	if e.config.EmergencyStopLoss > 0 {
		totalPnL := e.metrics.TotalPnL
		if totalPnL < 0 && ((-totalPnL / e.metrics.InitialCapital) * 100) >= e.config.EmergencyStopLoss {
			return true
		}
	}

	return false
}

// updateMetrics periodically updates performance metrics
func (e *TradingEngine) updateMetrics() {
	ticker := time.NewTicker(time.Minute)
	defer ticker.Stop()

	for {
		select {
		case <-e.stopChan:
			return
		case <-e.emergencyStop:
			return
		case <-ticker.C:
			e.calculateMetrics()
		}
	}
}

// calculateMetrics calculates current performance metrics
func (e *TradingEngine) calculateMetrics() {
	e.mu.Lock()
	defer e.mu.Unlock()

	var totalPnL float64
	var totalTrades int

	for _, runner := range e.activeStrategies {
		state := runner.GetState()
		totalPnL += state.PnL
		totalTrades += state.TradesCount
	}

	e.metrics.TotalPnL = totalPnL
	e.metrics.TotalTrades = totalTrades
	e.metrics.LastUpdate = time.Now()

	// Calculate daily PnL (simplified - would need proper time tracking)
	if e.metrics.DayStartTime.IsZero() ||
	   time.Since(e.metrics.DayStartTime) > 24*time.Hour {
		e.metrics.DayStartTime = time.Now().Truncate(24 * time.Hour)
		e.metrics.DayStartPnL = totalPnL
	}
	e.metrics.DailyPnL = totalPnL - e.metrics.DayStartPnL
}